{"pages":[],"posts":[{"title":"ArcGIS服务器环境部署（10.5/10.6）","text":"关于ArcGIS 10.5/10.6 服务的部署，包括ArcGIS portal，ArcGIS server，ArcGIS map，ArcGIS pro等相关软件的安装及联合，以及中间使用过程中出现的一系列问题和解决方案，后期会更新此文。","link":"/hexo-blog/2019/04/30/ArcGIS-Server/"},{"title":"vue-cli单页面开发","text":"关于vue-cli脚手架的搭建，以及单页面模式的前后端分离开发,后续更新。","link":"/hexo-blog/2019/04/30/vue-cli/"},{"title":"nginx服务器相关配置","text":"关于nginx服务器的相关接触，后续会陆续更新。","link":"/hexo-blog/2019/04/30/index/"},{"title":"什么是ArcGIS","text":"ArcGIS简介ArcGIS 是一个全面的系统，用户可用其来收集、组织、管理、分析、交流和发布地理信息。作为世界领先的地理信息系统 (GIS) 构建和应用平台，ArcGIS 可供全世界的人们将地理知识应用到政府、企业、科技、教育和媒体领域。ArcGIS 可以发布地理信息，以便所有人都可以访问和使用。本系统可以在任何地点通过 web 浏览器、移动设备（例如智能手机和台式计算机）来使用。 ArcGIS有哪些功能 创建、共享和使用智能地图地图以一种有效的方式来组织、理解和传达大量信息，这种方式获得了普遍的认可。ArcGIS 可用于创建各种不同形式的地图，包括可以使用浏览器和移动设备访问的 web 地图、大幅面印刷地图、报告和演示文稿中包括的地图、地图册、地图集、嵌入应用程序的地图，等等。无论采用哪种发布形式，ArcGIS 地图作为一种智能地图都可以显示、集成与合成来自各种不同来源的丰富地理和描述性信息图层。 单击影像浏览地图或应用程序： The World Topographic Map by Esri incorporates data provided by the GIS community via the Community Maps Program. 编译地理信息ArcGIS 使您可以将多个来源的数据合成到一个统一的地理视图中。这些数据来源包括来自地理数据库的信息、来自数据库管理系统 (DBMS) 和其他企业级系统的表格数据、文件、电子表格、经地理标记的照片和视频、KML、CAD 数据、来自传感器的实时反馈、航空和卫星影像等。实际上，任何包含地理参考（例如街道地址、城市名称、地块标识符、GPS 坐标等）的信息记录，都可以在地图上定位和访问。Esri、数据提供商和世界各地成千上万的 GIS 机构和组织提供的即用型权威地理数据都可以包括在内。 创建和管理地理数据库地理数据库是专业 GIS 工作的核心。地理数据库使地理信息能够以结构化的形式存储，便于轻松管理、更新、重用和共享。ArcGIS 使您可以设计、创建、维护和使用地理数据库，无论您是单独工作还是在大企业工作。地理数据库通常用于存储和管理 GIS 中所使用的关键基础图层数据 - 例如宗地、行政边界、公用设施网络、设施点、水文、高程、土壤等图层。这些集中管理的数据可以在 ArcGIS 地图中以各种不同的方式进行符号化、呈现、处理和发布。 ArcGIS 支持特大型的多用户数据库，其中的数据可以由多个用户同时使用和编辑，允许来自多个工作组和部门的不同用户访问、管理和更新。例如，后台用户和外业工作人员可以同时进行更新，所有组都可以立即看到他们的同事做出的更改。这些多用户数据库可以在标准的企业级关系数据库系统中实现和支持，例如 Oracle、SQL Server、 PostgreSQL、Informix 和 DB2。 单击影像浏览地图或应用程序： This sample demonstrates how to create graphics with 3D symbols and how to update these graphics using SketchViewModel in a SceneView. 12345678910111213141516171819const sketchVM = new SketchViewModel({ layer: gLayer, view: view, polygonSymbol: { type: \"polygon-3d\", symbolLayers: [{ type: \"extrude\", size: 10, // extrude by 10 meters material: { color: white }, edges: { type: \"solid\", size: \"3px\", color: [82, 82, 122, 0.8] } }] }}); 使用空间分析解决问题空间分析是 GIS 中最引人注目的功能之一。空间分析的目标是根据您的数据产生新的信息，以更好的做出决策。符号化数据并在地图上查看它这一过程本身就是一种形式的分析，并且地图本身即是对所显示的模式和关系的解译，而空间分析通过对地图中的数据应用地理、统计和数学运算又向前迈进了一步。ArcGIS 拥有数百种分析工具和操作方式，它们可以用于解决各种类型的问题，从查找满足特定条件的要素，到构建自然过程模型（例如经过各种地形的水流），或使用空间统计工具确定哪一组样本点可以揭示某种现象的分布（例如空气质量或人口特征）。 创建基于地图的应用程序通过创建应用程序可以将您的 ArcGIS 地图、数据、工具和专业知识转化为任何人都可以使用的信息产品。这事实上可以展现您在 GIS 方面的投资，使您的地图和功能可供各种不同的用户使用。 iGeology is a free smartphone app that lets you take over 500 geological maps of Britain wherever you go to discover the landscape beneath your feet! 使用地理和可视化功能交流和共享信息 ArcGIS 具有一些不可思议的新工具来创建 3D 可视化效果，包括城市的真实照片渲染。这些 3D 地图将来自地理数据库的权威数据（包括在 3D 环境中查询数据的功能）与 3D 可视化效果的丰富性和熟悉性结合到一起。通过创建精美的动画视频可以显示数据的飞行轨迹，例如分析结果，或使人们可以轻松可视化不同时间的变化情况。","link":"/hexo-blog/2019/04/30/ArcGIS/"},{"title":"自适应与响应式布局","text":"","link":"/hexo-blog/2019/05/06/web-responsive/"},{"title":"关于博客","text":"相关简介，后续更新，主要更新内容设计以下方面：VUE，AngularJS，react，ES6，webpack等前端方面的工作中接触到的以及个人总计的内容，另外关于ArcGIS服务器的相关部署，以及相关开发也会有较为详细的博文。针对于后端部分开发，由于本人着重于前端开发，后端开发也仅仅限于自己需求方面，所以水平上不及许多大牛，所以文章中如有写的不足或有错误的地方，还望大家多多指点，相互学习。","link":"/hexo-blog/2019/04/30/hello-world/"},{"title":"前端基础","text":"什么是html？html是一种网页标记语言，叫超文本标记语言，我们平时上网所看到的所有网页均来自于html，英文全称Hyper Text Markup Language。图片、链接、音乐、视频、程序等等现在都是通过html实现。但严格讲，它并不算编程语言，而是属于标记语言（标记标签 markup tag）。 html结构html的结构包括头部head，内容body，头部中可包含页面的标题title、关键词keywords、描述说明description等，它本身不会显示，主要是给浏览器看的，但非常之重要，可以影响网页显示的效果。里面就是网页要显示的主要内容了，里面有很多闭合标签构成。12345678910111213141516&lt;!DOCYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"xx.css\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt;&lt;/header&gt; &lt;article&gt; &lt;setcion&gt;&lt;/section&gt; &lt;aside&gt;&lt;/aside&gt; &lt;/article&gt; &lt;footer&gt;&lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; html各部分组成及作用一个网站由N多个网页组成，一个网页则有html、css和js构成。 html:html是主体，装载显示各种dom元素，属于结构框架层。 css:css用来装饰dom元素，属于显示表现层。 javascript:javascript用来控制dom元素，属于动作交互层。 HTML、XML、XHTML区别 HTML：超文本标记语言。语法松散，不严格。可以理解为通过一系列标签集合组合成一个文本文件，用于网页浏览。 XML：可扩展标记语言。用于存储数据和结构。XML来源于SGML，最初设计的目的是弥补HTML的不足，以强大的扩展性满足网络信息发布的需要，后来逐渐用于网络数据的转换和描述。注意，XML是用于传输数据，而非显示数据。其标签没有被预定义，需要根据自己需求自行定义标签。 XHTML：可扩展超文本标记语言。基于XML，作用与HTML类似，但语法更严格。XML虽然数据转换能力强大，完全可以替代HTML，但面对成千上万已有的站点，直接采用XML还为时过早。因此，在HTML4.01的基础上，用XML的规则对其进行扩展，得到了XHTML。其目的就是实现HTML向XML的过渡。 什么是html语义化？所谓html语义化实际上是除了让人容易通过标签的意思理解外，也要易于搜索引擎和浏览器爬虫理解。简单讲就是在合适的时间合适的地方使用合适的有语义信息的标签，例header,nav,aside,footer,section,ul,ol,em,strong等代替那些没有语义div,span信息的标签和big,center,strike,font,b,u等完全可以用css来取代的标签。同时，语义化也有助于seo和团队的开发维护，它的目的是让机器更接近人的思想，都能看懂，提高处理效率。比如我们经常犯的错误就是在一个div里面对某一个词要加重强调的时候，会使用span包起来，然后控制span的css为font-weight为bold。这种显然不是语义化，因为有加重强调的标签strong。 w3c的标准与标签语义化html页面编写的原则尽量遵循“结构表现行为分离”原则，规范可参考w3c的标准及规范。 W3C标准： （1）所有的标签都使用小写字母 （2）所有的属性值都放在引号里 （3）标签正确嵌套/关闭 （4）符合HTML,CSS,JS的规则 （5）结构层+表示层+行为层 遵循W3C标准和标签语义化有利于：让页面更友好，支持更多的终端，让更多的人可以使用互联网获得自己想要的信息。 （1）搜索引擎的搜索，有利于爬虫抓取内容 （2）支持多终端 （3）支持样式布局让站点支持个性化 （4）有利于开发和维护 （5）有利于降低成本 （6）提高用户体验 （7）页面能更好的呈现内容结构 浏览器内核的理解？浏览器的内核分为两部分：渲染引擎和JS引擎，但是由于JS引擎越来越独立了，所以内核也就是倾向渲染引擎。但是因为各个浏览器的内核不一样，所以它们的渲染引擎就不一样，所以渲染出来的页面也就不一样，这就是为什么浏览器有差异性，为什么我们要去适配浏览器的兼容性。 浏览器的内核有哪些？ firefox内核：Gecko IE TT 360 世界之窗 搜狗浏览器内核：Trident Opera：Presto 现为：Blink Safari Chrome：Webkit Chrome：blink H5新特性+新语义化标签HTML5不是SGML（标准通用标记语言）的子集了，主要是关于图像，位置，存储多任务等功能的增加。 新语义化标签： 绘画：canvas 视频：video 音频：audio article footer header nav section calendar date time email url search 低端IE通过document.createElement方法添加标签 新特性：客户端存储机制 cookie是网站为了标示用户身份而储存在用户本地终端上的数据（经过加密） cookie数据始终在同源的http请求中携带（即使不需要），在浏览器和服务器间来回传递。 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 存储大小： cookie数据不能超过4k sessionStorage和localStorage虽然也有存储大小的限制，可以达到5m更大。 期限时间： localStorage 浏览器关闭后数据不丢失除非删除数据 sessionStorage 数据在当前浏览器窗口关闭后自动删除 作用域是限定在文档源中，文档源url是通过协议+主机+端口决定的，同文档源可以共享数据，不同文档源不能共享 cookie 设置过期时间之前一直有效，即使窗口或浏览器关闭 cookie兼容性好，但是难用，是早期为服务器端脚本设计的客服端存储机制 webworker提供一个简单的方法使得web内容能够在后台运行脚本。 websocket 标签页之间的通信 1.地理位置API 地理位置API( https://www.w3.org/TR/geolocation-API/ )它能够允许浏览器（用户允许的情况下）检测用户的地理位置。 2.历史管理API 它允许web应用保存和更新它们的状态，以便当用户点击浏览器的后退与前进按钮的时候，无需刷新页面而立即做出响应。 3.跨文档消息传递 单位与字体 1.px:（Pixel）单位名称像素，相对长度单位，是相对显示器屏幕分辨率而言的。国内使用的多。 2.em:单位名称为相对长度单位，相对于当前对象内文本的字体尺寸。如果当前对行内文本的字体尺寸未被人设置，则相对于浏览器的默认字体尺寸。国外使用的多。 3.pt:单位名称为点(point)，绝对长度单位一般老版本的table使用，现在已经不用了。 4.rem:是CSS3中新增加的一个单位值，是相对长度单位。 em是相对于元素的父元素的font-size进行计算。 rem是相对于根元素html的font-size进行计算。 这样rem就绕开了复杂的层级关系，实现了类似于em单位的功能。 CSS 盒子模型： 标准盒子（w3c盒子模型）：content+padding+margin+border IE盒子模型：content(padding+border+content)+margin CSS选择符？哪些属性是可以继承？ id# class. 标签 相邻+ 子选择器 &gt; 后代选择 li a 通配符* 属性选择器 伪类选择器 可继续的样式：font-size font-family color ul li dl dd dt 不可继承的样式：border padding margin width height CSS优先级算法如何计算？ 同级权重，遵循就近原则 载入样式以最后载入的定位为准","link":"/hexo-blog/2019/05/05/web/"},{"title":"px,em,rem,vh,vw,vmin,vmax的区别","text":"CSS手册中关于font-size是这么介绍的：font-size 值可以是绝对或相对值。绝对值：将文本设置为指定的大小不允许用户在所有浏览器中改变文本大小（不利于可用性）绝对大小在确定了输出的物理尺寸时很有用相对大小：相对于周围的元素来设置大小允许用户在浏览器改变文本大小 注意：如果您没有规定字体大小，普通文本（比如段落）的默认大小是 16 像素 (16px=1em)。 px：为像素单位。它是显示屏上显示的每一个小点，为显示的最小单位。它是一个绝对尺寸单位；em：相对值，非固定大小单位1em 等于当前的字体尺寸。如果一个元素的 font-size 为 16 像素，那么对于该元素，1em 就等于 16 像素。在设置字体大小时，em 的值会相对于父元素的字体大小改变。浏览器中默认的文本大小是 16 像素。因此 1em 的默认尺寸是 16 像素。可以使用下面这个公式将像素转换为 em：pixels/16=em（注：16 等于父元素的默认字体大小，假设父元素的 font-size 为 20px，那么公式需改为：pixels/20=em）1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;px,em,rem,vh,vw,vmin,vmax的区别&lt;/title&gt; &lt;style&gt; div{font-size:1.5em;} &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"id1\"&gt;div1 &lt;div class=\"id2\"&gt;div2 &lt;div class=\"id3\"&gt;div3&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上图代码中规定div的字体大小同样都是1.5em,但是效果却是截然不同，根据公式我们可以得到如下换算结果：body默认的字体大小为16px； class为id1的div字体大小继承自父元素body：16px*1.5em = 24px class为id2的div字体大小继承自父元素id1：24px*1.5em = 36px class为id3的div字体大小继承自父元素id2：36px*1.5em = 54px 传送门：pxtoem单位转换提示：(在IE浏览器中，暂不支持重新调整用px作为字体的大小单位,虽然可以通过浏览器的缩放工具调整文本大小,但仅是对整个页面的调整,而不仅限于文本,W3C推荐使用em尺寸单位) rem：W3C官网是这样描述的“fontsize of the root element”，root element就是指的根元素html前面说到的em是相对于其父元素来设置字体大小的，这样就会存在一个问题，进行任何元素设置，都必须知道父元素的字体大小，在多次使用中往往会给我们带来无法预知的错误风险。而rem是相对于根元素html123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;px,em,rem,vh,vw,vmin,vmax的区别&lt;/title&gt; &lt;style&gt; div{font-size:1.5rem;} .id3{font-size:1.5em;} &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"id1\"&gt;div1 &lt;div class=\"id2\"&gt;div2 &lt;div class=\"id3\"&gt;div3&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html div1和div2的字体大小：继承自浏览器默认字体大小16px * 1.5rem = 24px div3的字体大小：继承自父元素div2的字体大小24px * 1.5em = 36px 浏览器的兼容性问题：rem是CSS3新引进来的一个度量单位，支持Mozilla Firefox 3.6+、Apple Safari 5+、Google Chrome、IE9+和Opera11+，IE8及以下版本均不支持 % 百分比，相对长度单位，相对于父元素的百分比值需要注意的是：em是相对于应用于当前当前元素的字体尺寸；而百分比则是相对于父元素的尺寸。123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div{margin:10px; background:#f0f;} .parent{width:200px; font-size:18px;} .em-demo{width:5em; background:#eae;} .percentage-demo{width:80%; background:#2f6;} &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"parent\"&gt; &lt;div class=\"em-demo\"&gt; 设置长度为5em demo &lt;/div&gt; &lt;div class=\"percentage-demo\"&gt; 设置长度为80% demo &lt;/div&gt;&lt;/div&gt;&lt;div id=\"id\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 可以看到，以em为单位的div宽度为90px：18px 5em，以%为单位的div宽度为160px：200px 0.8 对于px、em和百分比都能设置元素的尺寸和字体大小，但是它们各自有自己所不同的应用场景。不合理的运用，则会导致页面的混乱、难易维护和扩展。对于它们的使用，有如下几点被大家所认同的最佳实践： 尽量使用相对尺寸单位使用相对尺寸单位计量，则在调整页面的布局的时候，不需要遍历所有的内部DOM结构，重新设置内部子元素的尺寸大小，同时它也能更好的适应与多中分辨率和屏幕终端。采用相对定位，并不意味着页面整体的自适应。当然，对于希望整体网站的“响应式设计”，适应当今层出不穷的的各类访问终端，相对尺寸布局将发挥更大的价值。我们仅需要利用CSS3的@media查询来设置外围的整体宽度，以及少量在设备上不一致的用户体验。关于“响应式布局”，可以更多的参考bootstrap这类新兴的CSS框架。对于相对尺寸单位的设置：em和%因为它们相对的参考物不同，所以它们也有不同的使用场景。如果希望随着当前元素的字体尺寸而改变尺寸，则使用em最佳，如：行高、字体大小。相反，如果是随着父容器或者是整体页面布局而改变尺寸，则使用%更好，如元素的高度和宽度设置。 只在可预知的元素上使用绝对尺寸并不是所有的元素设置相对尺寸就是最佳的。对于如图表icon、如video这类多媒体元素、网页整体的宽度这类可预知尺寸，设置为绝对路径可能反而是最佳的选择。但他们需要试具体场景而定，从而获得最佳体验。不管我们如此设置相对尺寸，但在外层也总会有一些绝对尺寸度量，才可能存在百分比这类相对尺寸设置。 字体尺寸尽量使用em、rem和尽量使用相对尺寸单位一样，为了字体大小的可维护性和伸缩性，W3C更推荐使用em作为字体尺寸单位。需要注意的是，如果存在3层以及3层以上的字体相对尺寸的设置，则对于实际字体大小的计算，就会变得相对麻烦。这个时候，在满足浏览器兼容性的情况下，可以考虑使用CSS3的新特性rem：根据固定根元素的字体大小来设置相对尺寸大小，这也是近几年移动APP所兴起的使用方式。 rem的兼容性，我们可以用Can I Use网站获取。 @media查询做平台适配，但禁止随处滥用如上所说CSS3的@media查询，能帮助我们做到多平台终端的自适应布局，得到一个更好的用户体验。但这绝不意味着我们可以随处滥用它，在CSS代码中存在太多的平台差异的代码，这也会增加代码可读性、维护性的难度。更好的方式则是仅在必须使用它的场景下，合理的使用它，如页面外围的整体宽度，不同显示的菜单栏等。更多的体验适应性，可以移动到使用“流式布局”来实现。关于响应式设计，这是对开发周期、成本和平台体验的一个权衡的结果。如果不考虑开发、维护的成本，则为不同平台终端提供不同的页面设计，这样得到的用户体验会更友好。但在实际开发中，开发和维护成本、产品生命周期也是一个重要的权衡标准，而响应式设计则是它们之间的权衡结果。 vh和vw，vmin和vmaxvh和vw相对于视口的高度和宽度，而不是父元素的（CSS百分比是相对于包含它的最近的父元素的高度和宽度） 1vh 等于1/100的视口高度，1vw 等于1/100的视口宽度比如：浏览器高度900px，宽度为750px, 1 vh = 900px/100 = 9 px，1vw = 750px/100 = 7.5 px。 很容易实现与同屏幕等高的框： 1.slide {height: 100vh;} 设置一个和屏幕同宽的标题，h1{font-size:100vw}，那标题的字体大小就会自动根据浏览器的宽度进行缩放，以达到字体和viewport大小同步的效果。 vmin and vmax：关于视口高度和宽度两者的最小值或者最大值。比如，浏览器的宽度设置为1200px，高度设置为800px， 1vmax = 1200/100px = 12px， 1vmin = 800/100px = 8px。如果宽度设置为600px,高度设置为1080px, 1vmin就等于6px, 1vmax则等于10.8px。12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\"/&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; *{margin:0; padding:0;} .box { height: 100vmin; width: 100vmin; background:#f00;/*为了让用户看到*/ } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如果要让这个元素始终铺满整个视口的可视区域，只需要把上面的vmin改成vmax即可 123456*{margin:0; padding:0;}.box { height: 100vmax; width: 100vmax; background:#f00;/*为了让用户看到*/} vw, vh, vmin, vmax：IE9+局部支持，chrome/firefox/safari/opera支持，iOS safari 8+支持，Androidbrowser4.4+支持，chrome for android39支持 其它的单位还有：%:百分比in:寸cm:厘米mm:毫米pt:point，大约1/72寸 pc:pica，大约6pt，1/6寸 ex：取当前作用效果的字体的x的高度，在无法确定x高度的情况下以0.5em计算(IE11及以下均不支持，firefox/chrome/safari/opera/ios safari/android browser4.4+等均需属性加么有前缀) ch:以节点所使用字体中的“0”字符为基准，找不到时为0.5em(ie10+,chrome31+,safair7.1+,opera26+,ios safari 7.1+,android browser4.4+支持)","link":"/hexo-blog/2019/05/06/web-fontsize/"},{"title":"HTML规范","text":"传送门：html标准 原则：web标准的核心思想是结构（html）、表现（css）、行为（javascript）相互分离，互不干涉。并非某一个标准，而是一系列标准的集合。按照结构表现行为分离原则，编写网页时应先考虑结构，也就是在写html的时候，先不要管css样式的事儿，先把重点放在html的结构和语义化上，让html能够体现页面的结构或内容。之后在结构的基础上再去添加样式，最后在加上js交互行为。同时，在写javacript的时候尽量不要用js去直接操作样式，而是通过给html元素添加或删除class来控制样式变化。 规范。保证所写代码规范规整，近html5，远xhtml，保证结构表现行为分离，避免在html内使用样式属性和行为属性。 简洁。大道至简，保证代码的最简化，即便浏览器默认是忽略回车符的，也要避免多余的空格和空行出现。在任何时候都要牢记，能用一个元素解决的问题不要用两个，做减法而不是做加法。 语义。保持代码的语义化，尽量使用具有语义的元素。不要过多使用无意义的div。你的代码不光是给开发同事看的，更是给浏览器看，给搜索引擎蜘蛛看的。 实用。遵循标准，但是不能以牺牲实用性为代价。任何情况下都要保证使用最少的标签并保持最小的复杂度。 忠诚。选择一套规范，然后始终遵循。不管代码由多少人参与，都应该看起来像一个人写的一样。 字符。任何情况下只要是代码部分，必须使用英文半角而不是全角字符。 总结就是：实用为王的原则。遵循 HTML 标准和语义，不要以牺牲实用性为代价。任何时候都要尽量使用最少的标签并保持最小的复杂度。 语法： 小写。html元素和属性名全小写。 闭合。所有非空元素必须闭合，不要省略可选的结束标签（closing tag）要有始有终（即便是有些可选的结束标签可以省略，也不要省，都闭合）。空的自闭合（self-closing）元素不要再尾部添加空格和反斜杠了（即便是加了也不算错误也不要加，牢记原则）。HTML5 规范中明确说明这是可选的。 迁移。用两个空格来代替制表符（tab） – 这是唯一能保证在所有环境下获得一致展现的方法。 嵌套。所有元素必须正确嵌套 。不要出现段落里面嵌套标题或标题里嵌套段落的槽糕情况。同时，嵌套元素应当缩进一次（即两个空格）。 引号。对于属性的定义，确保全部使用双引号，绝不要使用单引号。如：1&lt;h1 class=\"hello-world\"&gt;Hello, world!&lt;/h1&gt; 文档： 文档类型使用html5标准文档模式（standard mode）&lt;!doctype html&gt;在第一行进行声明，文档申明前不允许出现任何非空字符，确保在每个浏览器中拥有一致的展现。 强烈建议html元素上指定lang属性。显示页面语言，有助于语言合成工具来确定怎样发音，以及翻译工具决定使用的规则等等。 指定明确的字符编码。让浏览器轻松、快速的确定适合网页内容的渲染方式，这样做的好处是，可以避免在 HTML 中使用字符实体标记（character entity），从而全部与文档编码一致，（推荐使用国际标准UTF-8）。 IE兼容模式 。Internet Explorer支持使用兼容性标签来指定使用什么版本的 IE来绘制渲染页面。如果不是特殊需要，通常通过edge mode来通知IE使用最新的兼容模式。 1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; 或者可以使用IE条件注释的方式兼容IE，但是不要添加额外的样式表 12345&lt;!--[if IE]&gt; &lt;script type=&quot;text/javascript&quot;&gt; alert(&quot;你使用的是IE浏览器！&quot;); &lt;/script&gt; &lt;![endif]--&gt; head部分的顺序（结束时不再需要反斜杠/）：第一部分： meta元素；（编码&gt;内核&gt;适配&gt;关键词&gt;描述&gt;作者&gt;蜘蛛&gt;缓存&gt;转码）第二部分： title元素；第三部分： link \\ style样式表；第四部分： base新窗口；第五部分： script需要的js文件； 文件拓展名默认使用html（推荐）或htm，便于操作系统或者程序辨认文件。 属性： 对于属性的定义，确保全部使用双引号，绝不要使用单引号。如果js控制时有问题，请使用 / 转义符解决 省略type属性。使用style、link、script，不用指定type属性，因为 text/css 和 text/javascript 分别是他们的默认值。 省略Boolean属性值。布尔型属性可以在声明时不赋值，XHTML 规范要求为其赋值，但是 HTML5 规范不需要。元素的布尔型属性如果有值，就是 true，如果没有值，就是 false。如disabled,checked,selected等。如果一定要为其赋值的话，请参考 WhatWG 规范：如果属性存在，其值必须是空字符串或 […] 属性的规范名称，并且不要在首尾添加空白符。 省略url类属性资源协议头。 属性顺序。html属性应该按照特定的顺序出现以保证易读性。class -&gt; id,name -&gt; data- -&gt; src,for,type,href,value -&gt; title,alt -&gt; aria-,role。class 用于标识高度可复用组件，因此应该排在首位。id 用于标识具体组件，应当谨慎使用，因此排在第二位。 多媒体元素添加替代属性。图像增加alt属性，音视频增加替代文字。 不手动设置tabindex属性，让浏览器自动设置。 元素： 避免冗余标签。编写 HTML 代码时，尽量避免多余的父元素。很多时候，这需要迭代和重构来实现。 避免JavaScript 生成标签。通过JS生成的标签会让内容变得不易查找、编辑，并且降低性能，能避免时尽量避免。 段落文字应该用&lt;p&gt;，避免使用&lt;br&gt;。 列表项放&lt;ul&gt;、&lt;ol&gt;、&lt;dl&gt;，不要使用一系列的&lt;div&gt;或&lt;p&gt; &lt;input&gt;使用for属性绑定&lt;label&gt;。 使用&lt;label&gt;标签包裹radio或checkbox和他们的文字，不用再使用for属性。 使用单选、复选替代下拉菜单。（radio or checkbox instead of select menu） form button应制定type类型，使用type=”submit”、type=”reset”或type=”button”。 首要的表单按钮首先出现(在dom中)，尤其是适用多个提交按钮的场合。视图中显示的顺序可以利用css修改。 有效使用&lt;thead&gt;、&lt;tfoot&gt;、&lt;tbody&gt;、&lt;th&gt;（scope属性）。可以把&lt;tfoot&gt;放&lt;tbody&gt;前提高加载速度。（如果不写tbody，浏览器也给你自动加上） 通过Javascript生成的元素让内容变得不易查找、编辑，并且降低性能。能避免时尽量避免。 css编码规范：语法： 为选择器分组时，将单独的选择器单独放在一行。 为了代码的易读性，在每个声明块的左花括号前添加一个空格。 声明块的右花括号应当单独成行。 每条声明语句的 : 后应该插入一个空格。 为了获得更准确的错误报告，每条声明都应该独占一行。 所有声明语句都应当以分号结尾。最后一条声明语句后面的分号是可选的，但是，如果省略这个分号，你的代码可能更易出错。 对于以逗号分隔的属性值，每个逗号后面都应该插入一个空格（例如，box-shadow）。 十六进制值应该全部小写，例如，#fff。在扫描文档时，小写字符易于分辨，因为他们的形式更易于区分。 尽量使用简写形式的十六进制值，例如，用 #fff 代替 #ffffff。 为选择器中的属性添加双引号，例如，input[type=&quot;text&quot;]。 避免为 0 值指定单位，例如，用 margin: 0; 代替 margin: 0px;。12345678910111213141516/* Bad CSS */.selector, .selector-secondary, .selector[type=text] { padding:15px; margin:0px 0px 15px; background-color:rgba(0, 0, 0, 0.5); box-shadow:0px 1px 2px #CCC,inset 0 1px 0 #FFFFFF}/* Good CSS */.selector,.selector-secondary,.selector[type=\"text\"] { padding: 15px; margin-bottom: 15px; background-color: rgba(0,0,0,.5); box-shadow: 0 1px 2px #ccc, inset 0 1px 0 #fff; 声明顺序：相关的属性声明应当归为一组，并按照下面的顺序排列： Positioning Box model Typographic Visual由于定位（positioning）可以从正常的文档流中移除元素，并且还能覆盖盒模型（box model）相关的样式，因此排在首位。盒模型排在第二位，因为它决定了组件的尺寸和位置。其他属性只是影响组件的内部（inside）或者是不影响前两组属性，因此排在后面。12345678910111213141516171819202122232425.declaration-order { /* Positioning */ position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: 100; /* Box-model */ display: block; float: right; width: 100px; height: 100px; /* Typography */ font: normal 13px &quot;Helvetica Neue&quot;, sans-serif; line-height: 1.5; color: #333; text-align: center; /* Visual */ background-color: #f5f5f5; border: 1px solid #e5e5e5; border-radius: 3px; /* Misc */ opacity: 1;} 完整的属性列表及其排列顺序请参考Recess。 @import：与标签相比，@import指令要慢很多，不光增加了额外的请求次数，还会导致不可预料的问题。常规解决办法： 使用多个元素 通过 Sass 或 Less 类似的 CSS 预处理器将多个 CSS 文件编译为一个文件 通过 Rails、Jekyll 或其他系统中提供过 CSS 文件合并功能 123456&lt;!-- Use link elements --&gt;&lt;link rel=\"stylesheet\" href=\"core.css\"&gt;&lt;!-- Avoid @imports --&gt;&lt;style&gt; @import url(\"more.css\");&lt;/style&gt; 媒体查询（Media query）的位置：将媒体查询放在尽可能相关规则的附近。不要将他们打包放在一个单一样式文件中或者放在文档底部。如果你把他们分开了，将来只会被大家遗忘。下面给出一个典型的实例。如：123456789.element { ... }.element-avatar { ... }.element-selected { ... }@media (min-width: 480px) { .element { ...} .element-avatar { ... } .element-selected { ... }} 单行规则声明对于只包含一条声明的样式，为了易读性和便于快速编辑，建议将语句放在同一行。对于带有多条声明的样式，还是应当将声明分为多行。这样做的关键因素是为了错误检测 -- 例如，CSS 校验器指出在 183 行有语法错误。如果是单行单条声明，你就不会忽略这个错误；如果是单行多条声明的话，你就要仔细分析避免漏掉错误了。123456789101112131415/* Single declarations on one line */.span1 { width: 60px; }.span2 { width: 140px; }.span3 { width: 220px; }/* Multiple declarations, one per line */.sprite { display: inline-block; width: 16px; height: 15px; background-image: url(../img/sprite.png);}.icon { background-position: 0 0; }.icon-home { background-position: 0 -20px; }.icon-account { background-position: 0 -40px; } 简写形式的属性声明在需要显示地设置所有值的情况下，应当尽量限制使用简写形式的属性声明。常见的滥用简写属性声明的情况如下：padding、margin、font、background、border、border-radius大部分情况下，我们不需要为简写形式的属性声明指定所有值。例如，HTML 的 heading 元素只需要设置上、下边距（margin）的值，因此，在必要的时候，只需覆盖这两个值就可以。过度使用简写形式的属性声明会导致代码混乱，并且会对属性值带来不必要的覆盖从而引起意外的副作用。12345678910111213141516/* Bad example */.element { margin: 0 0 10px; background: red; background: url(\"image.jpg\"); border-radius: 3px 3px 0 0;}/* Good example */.element { margin-bottom: 10px; background-color: red; background-image: url(\"image.jpg\"); border-top-left-radius: 3px; border-top-right-radius: 3px;} Less 和 Sass 中的嵌套：避免不必要的嵌套。这是因为虽然你可以使用嵌套，但是并不意味着应该使用嵌套。只有在必须将样式限制在父元素内（也就是后代选择器），并且存在多个需要嵌套的元素时才使用嵌套。123456789// Without nesting.table &gt; thead &gt; tr &gt; th { … }.table &gt; thead &gt; tr &gt; td { … }// With nesting.table &gt; thead &gt; tr { &gt; th { … } &gt; td { … }} Less 和 Sass 中的操作符：为了提高可读性，在圆括号中的数学计算表达式的数值、变量和操作符之间均添加一个空格123456789// Bad example.element { margin: 10px 0 @variable*2 10px;}// Good example.element { margin: 10px 0 (@variable * 2) 10px;} 注释：代码是由人编写并维护的。请确保你的代码能够自描述、注释良好并且易于他人理解。好的代码注释能够传达上下文关系和代码目的。不要简单地重申组件或 class 名称。对于较长的注释，务必书写完整的句子；对于一般性注解，可以书写简洁的短语。如果没有注释的习惯，那么在别人在维护代码的时候面对复杂的功能及逻辑就会无所适从，所以要养成一个善于注释的好习惯。1234567891011/* Bad example *//* Modal header */.modal-header { ...}/* Good example *//* Wrapping element for .modal-title and .modal-close */.modal-header { ...} class 命名： class 名称中只能出现小写字符和破折号（dashe）（不是下划线，也不是驼峰命名法）。破折号应当用于相关 class 的命名（类似于命名空间）（例如，.btn 和 .btn-danger）。 避免过度任意的简写。.btn 代表 button，但是 .s 不能表达任何意思。 class 名称应当尽可能短，并且意义明确。 使用有意义的名称。使用有组织的或目的明确的名称，不要使用表现形式（presentational）的名称。 基于最近的父 class 或基本（base） class 作为新 class 的前缀。 使用 .js-* class 来标识行为（与样式相对），并且不要将这些 class 包含到 CSS 文件中。 在为 Sass 和 Less 变量命名时也可以参考上面列出的各项规范。123456789/* Bad example */.t { ... }.red { ... }.header { ... }/* Good example */.tweet { ... }.important { ... }.tweet-header { ... } 选择器： 对于通用元素使用 class ，这样利于渲染性能的优化。 对于经常出现的组件，避免使用属性选择器（例如，[class^=&quot;...&quot;]）。浏览器的性能会受到这些因素的影响。 选择器要尽可能短，并且尽量限制组成选择器的元素个数，建议不要超过 3 。 只有在必要的时候才将 class 限制在最近的父元素内（也就是后代选择器）（例如，不使用带前缀的 class 时 – 前缀类似于命名空间）。123456789/* Bad example */span { ... }.page-container #stream .stream-item .tweet .tweet-header .username { ... }.avatar { ... }/* Good example */.avatar { ... }.tweet-header .username { ... }.tweet .avatar { ... } 代码组织： 以组件为单位组织代码段。 制定一致的注释规范。 使用一致的空白符将代码分隔成块，这样利于扫描较大的文档。 如果使用了多个 CSS 文件，将其按照组件而非页面的形式分拆，因为页面会被重组，而组件只会被移动。1234567891011121314151617/* * Component section heading */.element { ... }/* * Component section heading * * Sometimes you need to include optional context for the entire component. Do that up here if it's important enough. */.element { ... }/* Contextual sub-component or modifer */.element-heading { ... }","link":"/hexo-blog/2019/05/05/web-html/"}],"tags":[{"name":"服务部署","slug":"服务部署","link":"/hexo-blog/tags/服务部署/"},{"name":"vue","slug":"vue","link":"/hexo-blog/tags/vue/"},{"name":"nginx","slug":"nginx","link":"/hexo-blog/tags/nginx/"},{"name":"ArcGIS","slug":"ArcGIS","link":"/hexo-blog/tags/ArcGIS/"},{"name":"自适应与响应式布局","slug":"自适应与响应式布局","link":"/hexo-blog/tags/自适应与响应式布局/"},{"name":"简介","slug":"简介","link":"/hexo-blog/tags/简介/"},{"name":"前端","slug":"前端","link":"/hexo-blog/tags/前端/"},{"name":"尺寸","slug":"尺寸","link":"/hexo-blog/tags/尺寸/"},{"name":"HTML规范","slug":"HTML规范","link":"/hexo-blog/tags/HTML规范/"}],"categories":[{"name":"ArcGIS","slug":"ArcGIS","link":"/hexo-blog/categories/ArcGIS/"},{"name":"VUE","slug":"VUE","link":"/hexo-blog/categories/VUE/"},{"name":"服务器","slug":"服务器","link":"/hexo-blog/categories/服务器/"},{"name":"什么是ArcGIS","slug":"ArcGIS/什么是ArcGIS","link":"/hexo-blog/categories/ArcGIS/什么是ArcGIS/"},{"name":"ArcGIS4.5/4.6服务部署","slug":"ArcGIS/ArcGIS4-5-4-6服务部署","link":"/hexo-blog/categories/ArcGIS/ArcGIS4-5-4-6服务部署/"},{"name":"前端","slug":"前端","link":"/hexo-blog/categories/前端/"},{"name":"博客","slug":"博客","link":"/hexo-blog/categories/博客/"},{"name":"vue-cli","slug":"VUE/vue-cli","link":"/hexo-blog/categories/VUE/vue-cli/"},{"name":"nginx","slug":"服务器/nginx","link":"/hexo-blog/categories/服务器/nginx/"},{"name":"自适应与响应式布局","slug":"前端/自适应与响应式布局","link":"/hexo-blog/categories/前端/自适应与响应式布局/"},{"name":"简介","slug":"博客/简介","link":"/hexo-blog/categories/博客/简介/"},{"name":"前端基础","slug":"前端/前端基础","link":"/hexo-blog/categories/前端/前端基础/"},{"name":"几个单位的区别","slug":"前端/几个单位的区别","link":"/hexo-blog/categories/前端/几个单位的区别/"},{"name":"HTML规范","slug":"前端/HTML规范","link":"/hexo-blog/categories/前端/HTML规范/"}]}